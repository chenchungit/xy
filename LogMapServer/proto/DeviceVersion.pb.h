// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: DeviceVersion.proto

#ifndef PROTOBUF_INCLUDED_DeviceVersion_2eproto
#define PROTOBUF_INCLUDED_DeviceVersion_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_DeviceVersion_2eproto 

namespace protobuf_DeviceVersion_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[3];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_DeviceVersion_2eproto
namespace NetProtocol {
class DeviceVersionRequest;
class DeviceVersionRequestDefaultTypeInternal;
extern DeviceVersionRequestDefaultTypeInternal _DeviceVersionRequest_default_instance_;
class DeviceVersionResponse;
class DeviceVersionResponseDefaultTypeInternal;
extern DeviceVersionResponseDefaultTypeInternal _DeviceVersionResponse_default_instance_;
class VersionParam;
class VersionParamDefaultTypeInternal;
extern VersionParamDefaultTypeInternal _VersionParam_default_instance_;
}  // namespace NetProtocol
namespace google {
namespace protobuf {
template<> ::NetProtocol::DeviceVersionRequest* Arena::CreateMaybeMessage<::NetProtocol::DeviceVersionRequest>(Arena*);
template<> ::NetProtocol::DeviceVersionResponse* Arena::CreateMaybeMessage<::NetProtocol::DeviceVersionResponse>(Arena*);
template<> ::NetProtocol::VersionParam* Arena::CreateMaybeMessage<::NetProtocol::VersionParam>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace NetProtocol {

enum DeviceVersion {
  D2S_VERSION_FILE_DEIFINE = 0,
  D2S_VERSION_FILE_REQUEST = 2000,
  S2D_VERSION_FILE_RESPONSE = 3000,
  DeviceVersion_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  DeviceVersion_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool DeviceVersion_IsValid(int value);
const DeviceVersion DeviceVersion_MIN = D2S_VERSION_FILE_DEIFINE;
const DeviceVersion DeviceVersion_MAX = S2D_VERSION_FILE_RESPONSE;
const int DeviceVersion_ARRAYSIZE = DeviceVersion_MAX + 1;

const ::google::protobuf::EnumDescriptor* DeviceVersion_descriptor();
inline const ::std::string& DeviceVersion_Name(DeviceVersion value) {
  return ::google::protobuf::internal::NameOfEnum(
    DeviceVersion_descriptor(), value);
}
inline bool DeviceVersion_Parse(
    const ::std::string& name, DeviceVersion* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DeviceVersion>(
    DeviceVersion_descriptor(), name, value);
}
enum VersionState {
  VERSION_STATE_SUCCESS = 0,
  VERSION_STATE_FAIL = 1,
  VersionState_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  VersionState_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool VersionState_IsValid(int value);
const VersionState VersionState_MIN = VERSION_STATE_SUCCESS;
const VersionState VersionState_MAX = VERSION_STATE_FAIL;
const int VersionState_ARRAYSIZE = VersionState_MAX + 1;

const ::google::protobuf::EnumDescriptor* VersionState_descriptor();
inline const ::std::string& VersionState_Name(VersionState value) {
  return ::google::protobuf::internal::NameOfEnum(
    VersionState_descriptor(), value);
}
inline bool VersionState_Parse(
    const ::std::string& name, VersionState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<VersionState>(
    VersionState_descriptor(), name, value);
}
// ===================================================================

class VersionParam : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NetProtocol.VersionParam) */ {
 public:
  VersionParam();
  virtual ~VersionParam();

  VersionParam(const VersionParam& from);

  inline VersionParam& operator=(const VersionParam& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  VersionParam(VersionParam&& from) noexcept
    : VersionParam() {
    *this = ::std::move(from);
  }

  inline VersionParam& operator=(VersionParam&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const VersionParam& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VersionParam* internal_default_instance() {
    return reinterpret_cast<const VersionParam*>(
               &_VersionParam_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(VersionParam* other);
  friend void swap(VersionParam& a, VersionParam& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline VersionParam* New() const final {
    return CreateMaybeMessage<VersionParam>(NULL);
  }

  VersionParam* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<VersionParam>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const VersionParam& from);
  void MergeFrom(const VersionParam& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VersionParam* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string describeFlag = 1;
  void clear_describeflag();
  static const int kDescribeFlagFieldNumber = 1;
  const ::std::string& describeflag() const;
  void set_describeflag(const ::std::string& value);
  #if LANG_CXX11
  void set_describeflag(::std::string&& value);
  #endif
  void set_describeflag(const char* value);
  void set_describeflag(const char* value, size_t size);
  ::std::string* mutable_describeflag();
  ::std::string* release_describeflag();
  void set_allocated_describeflag(::std::string* describeflag);

  // int32 index = 2;
  void clear_index();
  static const int kIndexFieldNumber = 2;
  ::google::protobuf::int32 index() const;
  void set_index(::google::protobuf::int32 value);

  // int32 offset = 3;
  void clear_offset();
  static const int kOffsetFieldNumber = 3;
  ::google::protobuf::int32 offset() const;
  void set_offset(::google::protobuf::int32 value);

  // int32 MaxLenght = 4;
  void clear_maxlenght();
  static const int kMaxLenghtFieldNumber = 4;
  ::google::protobuf::int32 maxlenght() const;
  void set_maxlenght(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:NetProtocol.VersionParam)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr describeflag_;
  ::google::protobuf::int32 index_;
  ::google::protobuf::int32 offset_;
  ::google::protobuf::int32 maxlenght_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_DeviceVersion_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DeviceVersionRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NetProtocol.DeviceVersionRequest) */ {
 public:
  DeviceVersionRequest();
  virtual ~DeviceVersionRequest();

  DeviceVersionRequest(const DeviceVersionRequest& from);

  inline DeviceVersionRequest& operator=(const DeviceVersionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DeviceVersionRequest(DeviceVersionRequest&& from) noexcept
    : DeviceVersionRequest() {
    *this = ::std::move(from);
  }

  inline DeviceVersionRequest& operator=(DeviceVersionRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DeviceVersionRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DeviceVersionRequest* internal_default_instance() {
    return reinterpret_cast<const DeviceVersionRequest*>(
               &_DeviceVersionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(DeviceVersionRequest* other);
  friend void swap(DeviceVersionRequest& a, DeviceVersionRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DeviceVersionRequest* New() const final {
    return CreateMaybeMessage<DeviceVersionRequest>(NULL);
  }

  DeviceVersionRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DeviceVersionRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DeviceVersionRequest& from);
  void MergeFrom(const DeviceVersionRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeviceVersionRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string DevMac = 2;
  void clear_devmac();
  static const int kDevMacFieldNumber = 2;
  const ::std::string& devmac() const;
  void set_devmac(const ::std::string& value);
  #if LANG_CXX11
  void set_devmac(::std::string&& value);
  #endif
  void set_devmac(const char* value);
  void set_devmac(const char* value, size_t size);
  ::std::string* mutable_devmac();
  ::std::string* release_devmac();
  void set_allocated_devmac(::std::string* devmac);

  // .NetProtocol.VersionParam VersionParamRequest = 1;
  bool has_versionparamrequest() const;
  void clear_versionparamrequest();
  static const int kVersionParamRequestFieldNumber = 1;
  private:
  const ::NetProtocol::VersionParam& _internal_versionparamrequest() const;
  public:
  const ::NetProtocol::VersionParam& versionparamrequest() const;
  ::NetProtocol::VersionParam* release_versionparamrequest();
  ::NetProtocol::VersionParam* mutable_versionparamrequest();
  void set_allocated_versionparamrequest(::NetProtocol::VersionParam* versionparamrequest);

  // @@protoc_insertion_point(class_scope:NetProtocol.DeviceVersionRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr devmac_;
  ::NetProtocol::VersionParam* versionparamrequest_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_DeviceVersion_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DeviceVersionResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NetProtocol.DeviceVersionResponse) */ {
 public:
  DeviceVersionResponse();
  virtual ~DeviceVersionResponse();

  DeviceVersionResponse(const DeviceVersionResponse& from);

  inline DeviceVersionResponse& operator=(const DeviceVersionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DeviceVersionResponse(DeviceVersionResponse&& from) noexcept
    : DeviceVersionResponse() {
    *this = ::std::move(from);
  }

  inline DeviceVersionResponse& operator=(DeviceVersionResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DeviceVersionResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DeviceVersionResponse* internal_default_instance() {
    return reinterpret_cast<const DeviceVersionResponse*>(
               &_DeviceVersionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(DeviceVersionResponse* other);
  friend void swap(DeviceVersionResponse& a, DeviceVersionResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DeviceVersionResponse* New() const final {
    return CreateMaybeMessage<DeviceVersionResponse>(NULL);
  }

  DeviceVersionResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DeviceVersionResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DeviceVersionResponse& from);
  void MergeFrom(const DeviceVersionResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeviceVersionResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes FileData = 3;
  void clear_filedata();
  static const int kFileDataFieldNumber = 3;
  const ::std::string& filedata() const;
  void set_filedata(const ::std::string& value);
  #if LANG_CXX11
  void set_filedata(::std::string&& value);
  #endif
  void set_filedata(const char* value);
  void set_filedata(const void* value, size_t size);
  ::std::string* mutable_filedata();
  ::std::string* release_filedata();
  void set_allocated_filedata(::std::string* filedata);

  // .NetProtocol.VersionParam VersionParamRequest = 2;
  bool has_versionparamrequest() const;
  void clear_versionparamrequest();
  static const int kVersionParamRequestFieldNumber = 2;
  private:
  const ::NetProtocol::VersionParam& _internal_versionparamrequest() const;
  public:
  const ::NetProtocol::VersionParam& versionparamrequest() const;
  ::NetProtocol::VersionParam* release_versionparamrequest();
  ::NetProtocol::VersionParam* mutable_versionparamrequest();
  void set_allocated_versionparamrequest(::NetProtocol::VersionParam* versionparamrequest);

  // .NetProtocol.VersionState State = 1;
  void clear_state();
  static const int kStateFieldNumber = 1;
  ::NetProtocol::VersionState state() const;
  void set_state(::NetProtocol::VersionState value);

  // bool isEnd = 4;
  void clear_isend();
  static const int kIsEndFieldNumber = 4;
  bool isend() const;
  void set_isend(bool value);

  // @@protoc_insertion_point(class_scope:NetProtocol.DeviceVersionResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr filedata_;
  ::NetProtocol::VersionParam* versionparamrequest_;
  int state_;
  bool isend_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_DeviceVersion_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// VersionParam

// string describeFlag = 1;
inline void VersionParam::clear_describeflag() {
  describeflag_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& VersionParam::describeflag() const {
  // @@protoc_insertion_point(field_get:NetProtocol.VersionParam.describeFlag)
  return describeflag_.GetNoArena();
}
inline void VersionParam::set_describeflag(const ::std::string& value) {
  
  describeflag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NetProtocol.VersionParam.describeFlag)
}
#if LANG_CXX11
inline void VersionParam::set_describeflag(::std::string&& value) {
  
  describeflag_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:NetProtocol.VersionParam.describeFlag)
}
#endif
inline void VersionParam::set_describeflag(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  describeflag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NetProtocol.VersionParam.describeFlag)
}
inline void VersionParam::set_describeflag(const char* value, size_t size) {
  
  describeflag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NetProtocol.VersionParam.describeFlag)
}
inline ::std::string* VersionParam::mutable_describeflag() {
  
  // @@protoc_insertion_point(field_mutable:NetProtocol.VersionParam.describeFlag)
  return describeflag_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* VersionParam::release_describeflag() {
  // @@protoc_insertion_point(field_release:NetProtocol.VersionParam.describeFlag)
  
  return describeflag_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VersionParam::set_allocated_describeflag(::std::string* describeflag) {
  if (describeflag != NULL) {
    
  } else {
    
  }
  describeflag_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), describeflag);
  // @@protoc_insertion_point(field_set_allocated:NetProtocol.VersionParam.describeFlag)
}

// int32 index = 2;
inline void VersionParam::clear_index() {
  index_ = 0;
}
inline ::google::protobuf::int32 VersionParam::index() const {
  // @@protoc_insertion_point(field_get:NetProtocol.VersionParam.index)
  return index_;
}
inline void VersionParam::set_index(::google::protobuf::int32 value) {
  
  index_ = value;
  // @@protoc_insertion_point(field_set:NetProtocol.VersionParam.index)
}

// int32 offset = 3;
inline void VersionParam::clear_offset() {
  offset_ = 0;
}
inline ::google::protobuf::int32 VersionParam::offset() const {
  // @@protoc_insertion_point(field_get:NetProtocol.VersionParam.offset)
  return offset_;
}
inline void VersionParam::set_offset(::google::protobuf::int32 value) {
  
  offset_ = value;
  // @@protoc_insertion_point(field_set:NetProtocol.VersionParam.offset)
}

// int32 MaxLenght = 4;
inline void VersionParam::clear_maxlenght() {
  maxlenght_ = 0;
}
inline ::google::protobuf::int32 VersionParam::maxlenght() const {
  // @@protoc_insertion_point(field_get:NetProtocol.VersionParam.MaxLenght)
  return maxlenght_;
}
inline void VersionParam::set_maxlenght(::google::protobuf::int32 value) {
  
  maxlenght_ = value;
  // @@protoc_insertion_point(field_set:NetProtocol.VersionParam.MaxLenght)
}

// -------------------------------------------------------------------

// DeviceVersionRequest

// .NetProtocol.VersionParam VersionParamRequest = 1;
inline bool DeviceVersionRequest::has_versionparamrequest() const {
  return this != internal_default_instance() && versionparamrequest_ != NULL;
}
inline void DeviceVersionRequest::clear_versionparamrequest() {
  if (GetArenaNoVirtual() == NULL && versionparamrequest_ != NULL) {
    delete versionparamrequest_;
  }
  versionparamrequest_ = NULL;
}
inline const ::NetProtocol::VersionParam& DeviceVersionRequest::_internal_versionparamrequest() const {
  return *versionparamrequest_;
}
inline const ::NetProtocol::VersionParam& DeviceVersionRequest::versionparamrequest() const {
  const ::NetProtocol::VersionParam* p = versionparamrequest_;
  // @@protoc_insertion_point(field_get:NetProtocol.DeviceVersionRequest.VersionParamRequest)
  return p != NULL ? *p : *reinterpret_cast<const ::NetProtocol::VersionParam*>(
      &::NetProtocol::_VersionParam_default_instance_);
}
inline ::NetProtocol::VersionParam* DeviceVersionRequest::release_versionparamrequest() {
  // @@protoc_insertion_point(field_release:NetProtocol.DeviceVersionRequest.VersionParamRequest)
  
  ::NetProtocol::VersionParam* temp = versionparamrequest_;
  versionparamrequest_ = NULL;
  return temp;
}
inline ::NetProtocol::VersionParam* DeviceVersionRequest::mutable_versionparamrequest() {
  
  if (versionparamrequest_ == NULL) {
    auto* p = CreateMaybeMessage<::NetProtocol::VersionParam>(GetArenaNoVirtual());
    versionparamrequest_ = p;
  }
  // @@protoc_insertion_point(field_mutable:NetProtocol.DeviceVersionRequest.VersionParamRequest)
  return versionparamrequest_;
}
inline void DeviceVersionRequest::set_allocated_versionparamrequest(::NetProtocol::VersionParam* versionparamrequest) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete versionparamrequest_;
  }
  if (versionparamrequest) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      versionparamrequest = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, versionparamrequest, submessage_arena);
    }
    
  } else {
    
  }
  versionparamrequest_ = versionparamrequest;
  // @@protoc_insertion_point(field_set_allocated:NetProtocol.DeviceVersionRequest.VersionParamRequest)
}

// string DevMac = 2;
inline void DeviceVersionRequest::clear_devmac() {
  devmac_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DeviceVersionRequest::devmac() const {
  // @@protoc_insertion_point(field_get:NetProtocol.DeviceVersionRequest.DevMac)
  return devmac_.GetNoArena();
}
inline void DeviceVersionRequest::set_devmac(const ::std::string& value) {
  
  devmac_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NetProtocol.DeviceVersionRequest.DevMac)
}
#if LANG_CXX11
inline void DeviceVersionRequest::set_devmac(::std::string&& value) {
  
  devmac_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:NetProtocol.DeviceVersionRequest.DevMac)
}
#endif
inline void DeviceVersionRequest::set_devmac(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  devmac_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NetProtocol.DeviceVersionRequest.DevMac)
}
inline void DeviceVersionRequest::set_devmac(const char* value, size_t size) {
  
  devmac_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NetProtocol.DeviceVersionRequest.DevMac)
}
inline ::std::string* DeviceVersionRequest::mutable_devmac() {
  
  // @@protoc_insertion_point(field_mutable:NetProtocol.DeviceVersionRequest.DevMac)
  return devmac_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DeviceVersionRequest::release_devmac() {
  // @@protoc_insertion_point(field_release:NetProtocol.DeviceVersionRequest.DevMac)
  
  return devmac_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DeviceVersionRequest::set_allocated_devmac(::std::string* devmac) {
  if (devmac != NULL) {
    
  } else {
    
  }
  devmac_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), devmac);
  // @@protoc_insertion_point(field_set_allocated:NetProtocol.DeviceVersionRequest.DevMac)
}

// -------------------------------------------------------------------

// DeviceVersionResponse

// .NetProtocol.VersionState State = 1;
inline void DeviceVersionResponse::clear_state() {
  state_ = 0;
}
inline ::NetProtocol::VersionState DeviceVersionResponse::state() const {
  // @@protoc_insertion_point(field_get:NetProtocol.DeviceVersionResponse.State)
  return static_cast< ::NetProtocol::VersionState >(state_);
}
inline void DeviceVersionResponse::set_state(::NetProtocol::VersionState value) {
  
  state_ = value;
  // @@protoc_insertion_point(field_set:NetProtocol.DeviceVersionResponse.State)
}

// .NetProtocol.VersionParam VersionParamRequest = 2;
inline bool DeviceVersionResponse::has_versionparamrequest() const {
  return this != internal_default_instance() && versionparamrequest_ != NULL;
}
inline void DeviceVersionResponse::clear_versionparamrequest() {
  if (GetArenaNoVirtual() == NULL && versionparamrequest_ != NULL) {
    delete versionparamrequest_;
  }
  versionparamrequest_ = NULL;
}
inline const ::NetProtocol::VersionParam& DeviceVersionResponse::_internal_versionparamrequest() const {
  return *versionparamrequest_;
}
inline const ::NetProtocol::VersionParam& DeviceVersionResponse::versionparamrequest() const {
  const ::NetProtocol::VersionParam* p = versionparamrequest_;
  // @@protoc_insertion_point(field_get:NetProtocol.DeviceVersionResponse.VersionParamRequest)
  return p != NULL ? *p : *reinterpret_cast<const ::NetProtocol::VersionParam*>(
      &::NetProtocol::_VersionParam_default_instance_);
}
inline ::NetProtocol::VersionParam* DeviceVersionResponse::release_versionparamrequest() {
  // @@protoc_insertion_point(field_release:NetProtocol.DeviceVersionResponse.VersionParamRequest)
  
  ::NetProtocol::VersionParam* temp = versionparamrequest_;
  versionparamrequest_ = NULL;
  return temp;
}
inline ::NetProtocol::VersionParam* DeviceVersionResponse::mutable_versionparamrequest() {
  
  if (versionparamrequest_ == NULL) {
    auto* p = CreateMaybeMessage<::NetProtocol::VersionParam>(GetArenaNoVirtual());
    versionparamrequest_ = p;
  }
  // @@protoc_insertion_point(field_mutable:NetProtocol.DeviceVersionResponse.VersionParamRequest)
  return versionparamrequest_;
}
inline void DeviceVersionResponse::set_allocated_versionparamrequest(::NetProtocol::VersionParam* versionparamrequest) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete versionparamrequest_;
  }
  if (versionparamrequest) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      versionparamrequest = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, versionparamrequest, submessage_arena);
    }
    
  } else {
    
  }
  versionparamrequest_ = versionparamrequest;
  // @@protoc_insertion_point(field_set_allocated:NetProtocol.DeviceVersionResponse.VersionParamRequest)
}

// bytes FileData = 3;
inline void DeviceVersionResponse::clear_filedata() {
  filedata_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DeviceVersionResponse::filedata() const {
  // @@protoc_insertion_point(field_get:NetProtocol.DeviceVersionResponse.FileData)
  return filedata_.GetNoArena();
}
inline void DeviceVersionResponse::set_filedata(const ::std::string& value) {
  
  filedata_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NetProtocol.DeviceVersionResponse.FileData)
}
#if LANG_CXX11
inline void DeviceVersionResponse::set_filedata(::std::string&& value) {
  
  filedata_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:NetProtocol.DeviceVersionResponse.FileData)
}
#endif
inline void DeviceVersionResponse::set_filedata(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  filedata_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NetProtocol.DeviceVersionResponse.FileData)
}
inline void DeviceVersionResponse::set_filedata(const void* value, size_t size) {
  
  filedata_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NetProtocol.DeviceVersionResponse.FileData)
}
inline ::std::string* DeviceVersionResponse::mutable_filedata() {
  
  // @@protoc_insertion_point(field_mutable:NetProtocol.DeviceVersionResponse.FileData)
  return filedata_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DeviceVersionResponse::release_filedata() {
  // @@protoc_insertion_point(field_release:NetProtocol.DeviceVersionResponse.FileData)
  
  return filedata_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DeviceVersionResponse::set_allocated_filedata(::std::string* filedata) {
  if (filedata != NULL) {
    
  } else {
    
  }
  filedata_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), filedata);
  // @@protoc_insertion_point(field_set_allocated:NetProtocol.DeviceVersionResponse.FileData)
}

// bool isEnd = 4;
inline void DeviceVersionResponse::clear_isend() {
  isend_ = false;
}
inline bool DeviceVersionResponse::isend() const {
  // @@protoc_insertion_point(field_get:NetProtocol.DeviceVersionResponse.isEnd)
  return isend_;
}
inline void DeviceVersionResponse::set_isend(bool value) {
  
  isend_ = value;
  // @@protoc_insertion_point(field_set:NetProtocol.DeviceVersionResponse.isEnd)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace NetProtocol

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::NetProtocol::DeviceVersion> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::NetProtocol::DeviceVersion>() {
  return ::NetProtocol::DeviceVersion_descriptor();
}
template <> struct is_proto_enum< ::NetProtocol::VersionState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::NetProtocol::VersionState>() {
  return ::NetProtocol::VersionState_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_DeviceVersion_2eproto
